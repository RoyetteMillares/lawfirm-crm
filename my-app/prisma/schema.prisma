generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}



// MULTI-TENANT MODELS ROY  
model Tenant {
  id           String       @id @default(cuid())
  name         String
  slug         String       @unique
  status       TenantStatus @default(TRIAL)
  plan         String       @default("trial") // trial, basic, pro, enterprise
  cases        Case[]
  // Contact & Settings
  contactEmail String?
  contactPhone String?
  website      String?
  address      String?
  settings     Json?

  // Branding (optional)
  logo         String?
  primaryColor String? // Hex color code

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users       User[]
  invitations TenantInvitation[]

   // NEW: Document relations
  documentTemplates DocumentTemplate[]
  documents         Document[]
  documentAuditLogs DocumentAuditLog[]

  @@index([slug])
  @@index([status])
  @@map("tenants")
}

enum TenantStatus {
  TRIAL // 20-day trial
  ACTIVE // Paying customer
  SUSPENDED // Payment failed
  CANCELED // Subscription canceled
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String?   @unique
  name          String?
  passwordHash  String? // Only for email/password users roy
  image         String?
  emailVerified DateTime?
  assignedCases Case[]    @relation("AssignedCases")

  // Multi-tenant fields
  role     UserRole   @default(ENDUSER)
  tenantId String? // null for platform admins
  status   UserStatus @default(ACTIVE)

  // Profile
  phone String?
  title String? // Job title (e.g., "Partner", "Associate")
  bio   String? @db.Text

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  // Relations
  tenant   Tenant?   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  accounts Account[]
  sessions Session[]

  @@index([tenantId])
  @@index([role])
  @@index([email])
  @@index([status])
  @@map("users")
}

enum UserRole {
  ADMIN // Platform administrator (Legal Fusion owner)
  LAWFIRMOWNER // Tenant owner (can manage everything in their tenant)
  LAWFIRMSTAFF // Tenant staff member (limited access)
  ENDUSER // End client (can only see their own cases)
}

enum UserStatus {
  ACTIVE // Can sign in
  DISABLED // Cannot sign in
  PENDING_INVITATION // Invited but not accepted
}

// TENANT INVITATIONS

model TenantInvitation {
  id         String    @id @default(cuid())
  email      String
  role       UserRole
  tenantId   String
  token      String    @unique
  expiresAt  DateTime
  acceptedAt DateTime?

  invitedBy String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([token])
  @@index([tenantId])
  @@map("tenant_invitations")
}

// NEXTAUTH MODELS (OAuth & Sessions)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// AUDIT LOG (Important for legal compliance)
model AuditLog {
  id           String  @id @default(cuid())
  userId       String? // Who performed the action
  tenantId     String? // Which tenant (for filtering)
  action       String  // CREATED_CASE, ASSIGNED_CASE, UPDATED_CASE, DELETED_CASE, etc.
  resource     String  // Case, User, Template, etc.
  resourceId   String? // ID of the resource
  oldValues    Json?   // Previous state (for diffs)
  newValues    Json?   // New state (for compliance)
  metadata     Json?   // Additional context
  ipAddress    String?
  userAgent    String?
  description  String? // Human-readable log entry

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([tenantId])
  @@index([action])
  @@index([resourceId])
  @@index([createdAt])
  @@map("audit_logs")
}

enum CaseStatus {
  OPEN
  CLOSED
  PENDING
  ON_HOLD
  DELETED
}

model Case {
  id           String     @id @default(cuid())
  tenantId     String
  title        String
  description  String?
  status       CaseStatus @default(OPEN)
  assignedToId String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  tenant     Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  assignedTo User?  @relation("AssignedCases", fields: [assignedToId], references: [id])
   documents    Document[] // NEW: Link to generated documents

  @@index([tenantId])
  @@index([assignedToId])
  @@map("cases")
}

// ============================================
// DOCUMENT TEMPLATE MANAGEMENT
// ============================================

model DocumentTemplate {
  id              String    @id @default(cuid())
  tenantId        String
  name            String    // "Retainer Agreement", "Settlement Offer"
  slug            String    // URL-friendly identifier
  description     String?   @db.Text
  category        String    // "agreement", "demand", "settlement", "intake", "motion"
  
  // Template content (Handlebars syntax with {{variables}})
  // Example: "Client {{clientName}} agrees to retain {{firmName}}"
  htmlContent     String    @db.Text
  
  // List of required variables this template uses
  // Auto-extracted from handlebars placeholders
  requiredFields  Json      // ["clientName", "caseId", "amount", "date"]
  
  // Field mappings: template variable â†’ case/user data path
  // { clientName: "case.client.name", amount: "case.settlementAmount" }
  fieldMappings   Json
  
  // Signature fields: positions and labels for DocuSign/PDF
  // [{ id: "sig1", name: "clientSignature", label: "Client Signature", x: 100, y: 200, width: 150, height: 30 }]
  signatureFields Json?
  
  // Version control
  version         Int       @default(1)
  previousVersionId String? // Link to prior version
  
  // Metadata
  isPublished     Boolean   @default(false)
  isArchived      Boolean   @default(false)
  createdBy       String    // User ID
  publishedBy     String?   // User ID who published
  publishedAt     DateTime?
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  documents       Document[]
  
  @@unique([tenantId, slug])
  @@index([tenantId])
  @@index([category])
  @@index([isPublished])
  @@map("document_templates")
}

// ============================================
// GENERATED DOCUMENTS (from templates)
// ============================================

model Document {
  id                String    @id @default(cuid())
  tenantId          String
  templateId        String
  caseId            String
  
  // Document metadata
  title             String    // "Retainer Agreement - Smith vs. State"
  internalNotes     String?   @db.Text
  
  // Document state
  status            String    @default("draft") // "draft", "rendered", "sent", "signed", "completed", "rejected", "expired"
  
  // Recipient info
  recipientEmail    String
  recipientName     String?
  recipientType     String    // "client", "third_party", "opposing_counsel", "witness"
  
  // Document content
  renderedHtml      String?   @db.Text // Filled HTML (before PDF)
  pdfUrl            String?   // S3/GCS URL to rendered PDF
  pdfStoragePath    String?   // Internal storage identifier
  
  // Field substitution log (for audit trail)
  // { clientName: "John Doe", caseId: "CASE-2025-001", amount: "$50,000" }
  substitutedValues Json      // Encrypted - what values were used
  
  // Signature tracking
  signatureData     Json?     // Signature image/metadata if signed locally
  signedAt          DateTime?
  signedBy          String?   // Email or ID of signer
  signatureUrl      String?   // URL to signed document
  
  // DocuSign integration
  docusignEnvelopeId String?
  docusignStatus    String?   // "sent", "signed", "voided"
  docusignSignedAt  DateTime?
  
  // External integrations
  ghlContactId      String?   // GoHighLevel contact ID (for CRM sync)
  externalStatus    String?   // Sync status with third-party systems
  
  // Distribution
  sentAt            DateTime?
  sentBy            String    // User ID who sent it
  sentVia           String?   // "email", "docusign", "ghl", "manual"
  viewedAt          DateTime?
  viewedCount       Int       @default(0)
  
  // Rejection/Expiration
  rejectedAt        DateTime?
  rejectionReason   String?
  expiresAt         DateTime? // For time-limited documents
  
  // Audit
  createdBy         String    // User ID who created
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  tenant            Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  template          DocumentTemplate @relation(fields: [templateId], references: [id])
  case              Case      @relation(fields: [caseId], references: [id], onDelete: Cascade)
  auditLogs         DocumentAuditLog[]
  
  @@index([tenantId])
  @@index([caseId])
  @@index([templateId])
  @@index([status])
  @@index([recipientEmail])
  @@index([createdAt])
  @@map("documents")
}

// ============================================
// AUDIT LOGGING (Compliance)
// ============================================

model DocumentAuditLog {
  id            String    @id @default(cuid())
  tenantId      String
  documentId    String
  
  action        String    // "TEMPLATE_CREATED", "DOCUMENT_RENDERED", "DOCUMENT_SENT", "DOCUMENT_SIGNED", "FIELD_SUBSTITUTED"
  actionDetails String    @db.Text // JSON with specific details
  
  // Who, What, When, Where, Why
  userId        String    // User ID performing action
  userEmail     String    // Email for audit trail
  timestamp     DateTime  @default(now())
  ipAddress     String?
  userAgent     String?
  
  // What was changed
  oldValues     Json?     // Previous state (for updates)
  newValues     Json?     // New state
  
  // Compliance metadata
  complianceContext String? // "GLBA", "HIPAA", "CCPA", etc.
  
  createdAt     DateTime  @default(now())
  
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  document      Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@index([tenantId])
  @@index([documentId])
  @@index([action])
  @@index([userId])
  @@index([timestamp])
  @@map("document_audit_logs")
}